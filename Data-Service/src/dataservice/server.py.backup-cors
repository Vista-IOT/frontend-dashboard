import threading
import asyncio
import signal
import sys
import json
import time
import os
from typing import Optional
from fastapi import FastAPI, HTTPException
from fastapi.responses import JSONResponse
import uvicorn
from .servers.modbus_server import modbus_server_thread
from .servers.opcua_server import opcua_server_thread
from .servers.iec104_server import iec104_server_thread
from .servers.snmp_server import snmp_server_thread
from .core.datastore import DATA_STORE
from .core.mqtt_forwarder import MqttForwarder
from .core.mapping_store import MODBUS_MAPPING, IEC104_MAPPING, OPCUA_MAPPING, SNMP_MAPPING
from .core.ipc import IpcServer

_START_TIME = time.time()


class ServiceManager:
    def __init__(self) -> None:
        self.modbus_stop = threading.Event()
        self.opcua_stop = threading.Event()
        self.iec104_stop = threading.Event()
        self.snmp_stop = threading.Event()
        self.modbus_thread: Optional[threading.Thread] = None
        self.opcua_thread: Optional[threading.Thread] = None
        self.iec104_thread: Optional[threading.Thread] = None
        self.snmp_thread: Optional[threading.Thread] = None

    def start_modbus(self):
        if self.modbus_thread and self.modbus_thread.is_alive():
            return
        self.modbus_stop.clear()
        self.modbus_thread = threading.Thread(target=modbus_server_thread, args=(self.modbus_stop,), daemon=True)
        self.modbus_thread.start()

    def stop_modbus(self):
        self.modbus_stop.set()

    def start_opcua(self):
        if self.opcua_thread and self.opcua_thread.is_alive():
            return
        self.opcua_stop.clear()
        def run():
            asyncio.run(opcua_server_thread(self.opcua_stop))
        self.opcua_thread = threading.Thread(target=run, daemon=True)
        self.opcua_thread.start()

    def stop_opcua(self):
        self.opcua_stop.set()

    def start_iec104(self):
        if self.iec104_thread and self.iec104_thread.is_alive():
            return
        self.iec104_stop.clear()
        self.iec104_thread = threading.Thread(target=iec104_server_thread, args=(self.iec104_stop,), daemon=True)
        self.iec104_thread.start()

    def stop_iec104(self):
        self.iec104_stop.set()

    def start_snmp(self):
        if self.snmp_thread and self.snmp_thread.is_alive():
            return
        self.snmp_stop.clear()
        self.snmp_thread = threading.Thread(target=snmp_server_thread, args=(self.snmp_stop,), daemon=True)
        self.snmp_thread.start()

    def stop_snmp(self):
        self.snmp_stop.set()


app = FastAPI(title="DataService", version="1.0.0")
services = ServiceManager()
mqtt_forwarder = MqttForwarder()
ipc_server = IpcServer()


@app.on_event("startup")
def on_startup():
    services.start_modbus()
    services.start_opcua()
    services.start_iec104()
    # services.start_snmp()  # Disabled due to asyncio event loop issues
    mqtt_forwarder.start()
    ipc_server.start()


@app.on_event("shutdown")
def on_shutdown():
    services.stop_modbus()
    services.stop_opcua()
    services.stop_iec104()
    # services.stop_snmp()  # Disabled due to asyncio event loop issues
    mqtt_forwarder.stop()
    ipc_server.stop()


@app.get("/health")
def health():
    return {"status": "ok"}


@app.get("/data")
def get_data():
    return JSONResponse(DATA_STORE.snapshot())


@app.get("/stats")
def stats():
    data_stats = DATA_STORE.get_statistics()
    return {
        "keys": data_stats['total_points'],
        "addresses": data_stats['total_addresses'], 
        "uptime_sec": int(time.time() - _START_TIME),
        "heap_est_bytes": data_stats['total_points'] * 24  # rough estimate
    }


@app.get("/addr")
def get_address_space():
    """Get the current address space (for debugging/testing)"""
    space = DATA_STORE.address_space()
    # Pad to show at least first 10 addresses
    padded = {}
    for i in range(max(10, max(space.keys()) + 1) if space else 10):
        padded[str(i)] = space.get(i, 0)
    return JSONResponse(padded)


@app.post("/register")
def register(body: dict):
    key = body.get('key')
    address = body.get('address')
    default = body.get('default', 0)
    data_type = body.get('data_type', 'float')
    units = body.get('units', '')
    allow_conflict = bool(body.get('allow_address_conflict', False))
    
    if not isinstance(key, str) or key == '':
        raise HTTPException(400, 'key required')
    try:
        DATA_STORE.register(
            key, 
            address=address, 
            default=default,
            data_type=data_type,
            units=units,
            allow_address_conflict=allow_conflict
        )
        data_id = DATA_STORE.ensure_id(key)
        return {'ok': True, 'id': data_id}
    except Exception as e:
        raise HTTPException(400, str(e))


@app.post("/register/bulk")
def bulk_register(body: dict):
    """
    Bulk register multiple data points for quick data ingestion
    
    Body format:
    {
        "points": [
            {
                "key": "temperature",
                "address": 40001,
                "default": 25.0,
                "data_type": "float",
                "units": "Â°C"
            },
            {
                "key": "pressure", 
                "address": 40002,
                "default": 1013.25,
                "data_type": "float",
                "units": "hPa"
            }
        ],
        "allow_address_conflict": false
    }
    """
    points = body.get('points', [])
    allow_conflict = bool(body.get('allow_address_conflict', False))
    
    if not isinstance(points, list) or len(points) == 0:
        raise HTTPException(400, 'points must be a non-empty list')
    
    results = []
    errors = []
    
    for i, point in enumerate(points):
        try:
            key = point.get('key')
            address = point.get('address')
            default = point.get('default', 0)
            data_type = point.get('data_type', 'float')
            units = point.get('units', '')
            
            if not isinstance(key, str) or key == '':
                errors.append(f"Point {i}: key required")
                continue
                
            DATA_STORE.register(
                key,
                address=address,
                default=default,
                data_type=data_type,
                units=units,
                allow_address_conflict=allow_conflict
            )
            data_id = DATA_STORE.ensure_id(key)
            results.append({
                'index': i,
                'key': key,
                'id': data_id,
                'ok': True
            })
        except Exception as e:
            errors.append(f"Point {i} ({point.get('key', 'unknown')}): {str(e)}")
            results.append({
                'index': i,
                'key': point.get('key', 'unknown'),
                'ok': False,
                'error': str(e)
            })
    
    return {
        'ok': len(errors) == 0,
        'total_points': len(points),
        'successful': len([r for r in results if r.get('ok')]),
        'failed': len([r for r in results if not r.get('ok')]),
        'results': results,
        'errors': errors
    }


@app.post("/write")
def write(body: dict):
    key = body.get('key')
    address = body.get('address')
    value = body.get('value')
    if key is None and address is None:
        raise HTTPException(400, 'key or address required')
    DATA_STORE.write(key if key is not None else int(address), value)
    return {'ok': True}



# ====================== PROTOCOL-SPECIFIC MAPPING ENDPOINTS ======================

@app.post('/mappings/modbus')
def set_modbus_mapping(body: dict):
    """Set Modbus-specific mapping"""
    data_id = body.get('id')
    key = body.get('key')
    register_address = body.get('register_address')
    function_code = body.get('function_code', 3)
    data_type = body.get('data_type', 'int16')
    access = body.get('access', 'rw')
    scaling_factor = body.get('scaling_factor', 1.0)
    endianess = body.get('endianess', 'big')
    description = body.get('description', '')
    
    if not isinstance(data_id, str) or data_id == '':
        raise HTTPException(400, 'id required')
    if not isinstance(key, str) or key == '':
        raise HTTPException(400, 'key required')
    if not isinstance(register_address, int):
        raise HTTPException(400, 'register_address must be integer')
    
    try:
        MODBUS_MAPPING.set_mapping(
            data_id, key, register_address, function_code, 
            data_type, access, scaling_factor, endianess, description
        )
        return {'ok': True}
    except Exception as e:
        raise HTTPException(400, str(e))

@app.get('/mappings/modbus')
def get_modbus_mappings():
    """Get all Modbus mappings"""
    return MODBUS_MAPPING.all()

@app.post('/mappings/opcua')
def set_opcua_mapping(body: dict):
    """Set OPC-UA specific mapping"""
    data_id = body.get('id')
    key = body.get('key')
    node_id = body.get('node_id')
    browse_name = body.get('browse_name')
    display_name = body.get('display_name')
    data_type = body.get('data_type', 'Float')
    value_rank = body.get('value_rank', -1)
    access_level = body.get('access_level', 'CurrentRead')
    timestamps = body.get('timestamps', 'Both')
    namespace = body.get('namespace', 2)
    description = body.get('description', '')
    
    if not isinstance(data_id, str) or data_id == '':
        raise HTTPException(400, 'id required')
    if not isinstance(key, str) or key == '':
        raise HTTPException(400, 'key required')
    if not isinstance(node_id, str) or node_id == '':
        raise HTTPException(400, 'node_id required')
    
    try:
        OPCUA_MAPPING.set_mapping(
            data_id, key, node_id, browse_name, display_name,
            data_type, value_rank, access_level, timestamps, namespace, description
        )
        return {'ok': True}
    except Exception as e:
        raise HTTPException(400, str(e))

@app.get('/mappings/opcua')
def get_opcua_mappings():
    """Get all OPC-UA mappings"""
    return OPCUA_MAPPING.all()

@app.post('/mappings/snmp')
def set_snmp_mapping(body: dict):
    """Set SNMP-specific mapping"""
    data_id = body.get('id')
    key = body.get('key')
    oid = body.get('oid')
    syntax = body.get('syntax', 'Gauge32')
    access = body.get('access', 'read-only')
    description = body.get('description', '')
    index = body.get('index')
    
    if not isinstance(data_id, str) or data_id == '':
        raise HTTPException(400, 'id required')
    if not isinstance(key, str) or key == '':
        raise HTTPException(400, 'key required')
    if not isinstance(oid, str) or oid == '':
        raise HTTPException(400, 'oid required')
    
    try:
        SNMP_MAPPING.set_mapping(data_id, key, oid, syntax, access, description, index)
        return {'ok': True}
    except Exception as e:
        raise HTTPException(400, str(e))

@app.get('/mappings/snmp')
def get_snmp_mappings():
    """Get all SNMP mappings"""
    return SNMP_MAPPING.all()

@app.post('/mappings/iec104')
def set_iec104_mapping(body: dict):
    data_id = body.get('id')
    key = body.get('key')
    ioa = body.get('ioa')
    type_id = body.get('type')
    if not isinstance(data_id, str) or data_id == '':
        raise HTTPException(400, 'id required')
    if not isinstance(key, str) or key == '':
        raise HTTPException(400, 'key required')
    if not isinstance(ioa, int):
        raise HTTPException(400, 'ioa must be integer')
    try:
        IEC104_MAPPING.set_mapping(data_id, key, ioa, type_id)
        return {'ok': True}
    except Exception as e:
        raise HTTPException(400, str(e))


@app.get('/mappings/iec104')
def get_iec104_mappings():
    return IEC104_MAPPING.all()


@app.post('/mappings/snmp')
def set_snmp_mapping(body: dict):
    data_id = body.get('id')
    key = body.get('key')
    oid_suffix = body.get('oid_suffix')
    type_id = body.get('type')
    if not isinstance(data_id, str) or data_id == '':
        raise HTTPException(400, 'id required')
    if not isinstance(key, str) or key == '':
        raise HTTPException(400, 'key required')
    if not isinstance(oid_suffix, int):
        raise HTTPException(400, 'oid_suffix must be integer')
    try:
        SNMP_MAPPING.set_mapping(data_id, key, oid_suffix, type_id)
        return {'ok': True}
    except Exception as e:
        raise HTTPException(400, str(e))


@app.get('/mappings/snmp')
def get_snmp_mappings():
    return SNMP_MAPPING.all()


@app.post("/services/{name}/enable")
def enable_service(name: str):
    name = name.lower()
    if name == 'modbus':
        services.start_modbus()
    elif name == 'opcua':
        services.start_opcua()
    elif name == 'iec104':
        services.start_iec104()
    elif name == 'snmp':
        pass  # SNMP service disabled due to asyncio event loop issues
    else:
        raise HTTPException(404, 'unknown service')
    return {'ok': True}


@app.post("/services/{name}/disable")
def disable_service(name: str):
    name = name.lower()
    if name == 'modbus':
        services.stop_modbus()
    elif name == 'opcua':
        services.stop_opcua()
    elif name == 'iec104':
        services.stop_iec104()
    elif name == 'snmp':
        pass  # SNMP service disabled due to asyncio event loop issues
    else:
        raise HTTPException(404, 'unknown service')
    return {'ok': True}


# ====================== DATA SERVICE SPECIFIC FEATURES ======================

@app.get("/detailed")
def get_detailed_data():
    """Get detailed data with metadata, quality, and timestamps"""
    return JSONResponse(DATA_STORE.detailed_snapshot())

@app.get("/history/{key}")
def get_history(key: str, limit: int = 100):
    """Get historical data for a specific key"""
    history = DATA_STORE.get_history(key, limit)
    if not history:
        raise HTTPException(404, f"No history found for key '{key}'")
    return JSONResponse(history)

@app.get("/datapoints")
def list_datapoints():
    """List all registered data points with their configuration"""
    detailed = DATA_STORE.detailed_snapshot()
    return JSONResponse([{
        'key': key,
        'address': info['address'],
        'data_type': info['data_type'],
        'units': info['units'],
        'current_value': info['value'],
        'quality': info['quality']
    } for key, info in detailed.items()])

@app.get("/statistics")
def get_statistics():
    """Get system statistics"""
    stats = DATA_STORE.get_statistics()
    stats.update({
        'uptime_seconds': time.time() - _START_TIME,
        'services': {
            'modbus': services.modbus_thread is not None and services.modbus_thread.is_alive(),
            'opcua': services.opcua_thread is not None and services.opcua_thread.is_alive(),
            'iec104': services.iec104_thread is not None and services.iec104_thread.is_alive(),
            'snmp': False  # Disabled
        }
    })
    return JSONResponse(stats)

@app.get("/address-space/info")
def get_address_space_info():
    """Get address space allocation information"""
    return JSONResponse(DATA_STORE.get_address_space_info())

@app.get("/health/detailed")
def health_detailed():
    """Detailed health check with service status"""
    services_status = {
        'modbus': {
            'running': services.modbus_thread is not None and services.modbus_thread.is_alive(),
            'port': int(os.getenv('MODBUS_PORT', '5020'))
        },
        'opcua': {
            'running': services.opcua_thread is not None and services.opcua_thread.is_alive(),
            'port': int(os.getenv('OPCUA_PORT', '4840'))
        },
        'iec104': {
            'running': services.iec104_thread is not None and services.iec104_thread.is_alive(),
            'port': int(os.getenv('IEC104_PORT', '2404'))
        },
        'snmp': {
            'running': False,
            'port': int(os.getenv('SNMP_PORT', '1161')),
            'status': 'disabled'
        }
    }
    
    # Check for data quality issues
    detailed = DATA_STORE.detailed_snapshot()
    quality_issues = sum(1 for info in detailed.values() if info['quality'] != 'GOOD')
    
    return JSONResponse({
        'status': 'healthy',
        'timestamp': time.time(),
        'uptime_seconds': time.time() - _START_TIME,
        'services': services_status,
        'data_quality': {
            'total_points': len(detailed),
            'quality_issues': quality_issues
        }
    })

@app.post("/simulate")
def simulate_data():
    """Simulate changing data values for testing"""
    import random
    
    # Simulate some changing values
    DATA_STORE.write('temperature', round(random.uniform(20.0, 35.0), 1))
    DATA_STORE.write('humidity', round(random.uniform(40.0, 80.0), 1))
    DATA_STORE.write('pressure', round(random.uniform(980.0, 1050.0), 1))
    
    # Update custom data points if they exist
    snapshot = DATA_STORE.snapshot()
    if 'power_consumption' in snapshot:
        DATA_STORE.write('power_consumption', round(random.uniform(100.0, 200.0), 2))
    if 'flow_rate' in snapshot:
        DATA_STORE.write('flow_rate', round(random.uniform(30.0, 70.0), 1))
    
    return {'ok': True, 'message': 'Data simulation updated'}


def main():
    # For backward-compat if directly executed
    uvicorn.run("dataservice.server:app", host="0.0.0.0", port=8080, reload=False)


if __name__ == "__main__":
    main()

# ====================== PROTOCOL-SPECIFIC MAPPING ENDPOINTS ======================

@app.post('/mappings/modbus')
def set_modbus_mapping(body: dict):
    """Set Modbus-specific mapping with proper Modbus attributes"""
    data_id = body.get('id')
    key = body.get('key')
    register_address = body.get('register_address')
    function_code = body.get('function_code', 3)  # Default: Holding Register
    data_type = body.get('data_type', 'int16')
    access = body.get('access', 'rw')
    scaling_factor = body.get('scaling_factor', 1.0)
    endianess = body.get('endianess', 'big')
    description = body.get('description', '')
    
    if not isinstance(data_id, str) or data_id == '':
        raise HTTPException(400, 'id required')
    if not isinstance(key, str) or key == '':
        raise HTTPException(400, 'key required')
    if not isinstance(register_address, int):
        raise HTTPException(400, 'register_address must be integer')
    
    try:
        MODBUS_MAPPING.set_mapping(
            data_id, key, register_address, function_code, 
            data_type, access, scaling_factor, endianess, description
        )
        return {'ok': True}
    except Exception as e:
        raise HTTPException(400, str(e))

@app.get('/mappings/modbus')
def get_modbus_mappings():
    """Get all Modbus mappings"""
    return MODBUS_MAPPING.all()

@app.post('/mappings/opcua')
def set_opcua_mapping(body: dict):
    """Set OPC-UA specific mapping with proper OPC-UA attributes"""
    data_id = body.get('id')
    key = body.get('key')
    node_id = body.get('node_id')
    browse_name = body.get('browse_name')
    display_name = body.get('display_name')
    data_type = body.get('data_type', 'Float')
    value_rank = body.get('value_rank', -1)
    access_level = body.get('access_level', 'CurrentRead')
    timestamps = body.get('timestamps', 'Both')
    namespace = body.get('namespace', 2)
    description = body.get('description', '')
    
    if not isinstance(data_id, str) or data_id == '':
        raise HTTPException(400, 'id required')
    if not isinstance(key, str) or key == '':
        raise HTTPException(400, 'key required')
    if not isinstance(node_id, str) or node_id == '':
        raise HTTPException(400, 'node_id required')
    
    try:
        OPCUA_MAPPING.set_mapping(
            data_id, key, node_id, browse_name, display_name,
            data_type, value_rank, access_level, timestamps, namespace, description
        )
        return {'ok': True}
    except Exception as e:
        raise HTTPException(400, str(e))

@app.get('/mappings/opcua')
def get_opcua_mappings():
    """Get all OPC-UA mappings"""
    return OPCUA_MAPPING.all()

